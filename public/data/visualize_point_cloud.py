#!/usr/bin/env python3
"""
Quick point cloud visualization script for lidar data.
Reads the output.txt file generated by run.py and creates an interactive 3D plot.
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import argparse
import sys


def load_point_cloud(filename):
    """Load point cloud data from text file."""
    try:
        data = np.loadtxt(filename)
        print(f"Loaded {len(data)} points from {filename}")
        return data
    except Exception as e:
        print(f"Error loading {filename}: {e}")
        sys.exit(1)


def analyze_point_cloud(data):
    """Analyze and print statistics about the point cloud."""
    print("\n=== Point Cloud Statistics ===")
    print(f"Number of points: {len(data):,}")
    print(f"X range: {data[:, 0].min():.3f} to {data[:, 0].max():.3f} meters")
    print(f"Y range: {data[:, 1].min():.3f} to {data[:, 1].max():.3f} meters")
    print(f"Z range: {data[:, 2].min():.3f} to {data[:, 2].max():.3f} meters")

    # Calculate distances from origin
    distances = np.sqrt(np.sum(data**2, axis=1))
    print(f"Mean distance from origin: {np.mean(distances):.3f} meters")
    print(f"Max distance from origin: {np.max(distances):.3f} meters")
    print(f"Min distance from origin: {np.min(distances):.3f} meters")


def create_visualization(
    data, color_mode="height", point_size=0.5, max_range=None, subsample=None
):
    """
    Create 3D matplotlib visualization of the point cloud.

    Args:
        data: Nx3 numpy array of XYZ coordinates
        color_mode: 'height', 'distance', 'intensity', or 'uniform'
        point_size: Size of points in the plot
        max_range: Maximum distance to display (None for all points)
        subsample: Subsample factor (e.g., 10 means every 10th point)
    """

    # Apply max range filter if specified
    if max_range is not None:
        distances = np.sqrt(np.sum(data**2, axis=1))
        mask = distances <= max_range
        data = data[mask]
        print(f"Filtered to {len(data):,} points within {max_range}m range")

    # Apply subsampling if specified
    if subsample is not None and subsample > 1:
        data = data[::subsample]
        print(f"Subsampled to {len(data):,} points (every {subsample}th point)")

    # Extract coordinates
    x, y, z = data[:, 0], data[:, 1], data[:, 2]

    # Set up the figure
    fig = plt.figure(figsize=(12, 9))
    ax = fig.add_subplot(111, projection="3d")

    # Configure colors based on mode
    if color_mode == "height":
        # Color by Z value (height) - common in lidar visualization
        colors = z
        colormap = "viridis"
        color_label = "Height (Z) [m]"
    elif color_mode == "distance":
        # Color by distance from origin
        colors = np.sqrt(x**2 + y**2 + z**2)
        colormap = "plasma"
        color_label = "Distance from origin [m]"
    elif color_mode == "intensity":
        # Color by Z value capped at 5m
        colors = np.minimum(np.absolute(z), 5)
        colormap = "jet"
        color_label = "Z (capped at 5m) [m]"
    else:  # uniform
        colors = "blue"
        colormap = None
        color_label = None

    # Create the scatter plot
    if colormap:
        scatter = ax.scatter(x, y, z, c=colors, cmap=colormap, s=point_size, alpha=0.8)
        # Add colorbar
        cbar = plt.colorbar(scatter, ax=ax, shrink=0.5, aspect=20)
        if color_label:
            cbar.set_label(color_label)
    else:
        ax.scatter(x, y, z, c=colors, s=point_size, alpha=0.8)

    # Set labels and title
    ax.set_xlabel("X [m]")
    ax.set_ylabel("Y [m]")
    ax.set_zlabel("Z [m]")
    ax.set_title("Lidar Point Cloud Visualization\n(First Frame)")

    # Set reasonable axis limits based on data
    data_range = max(
        data[:, 0].max() - data[:, 0].min(),
        data[:, 1].max() - data[:, 1].min(),
        data[:, 2].max() - data[:, 2].min(),
    )

    # Center the view around the data
    x_center = (data[:, 0].max() + data[:, 0].min()) / 2
    y_center = (data[:, 1].max() + data[:, 1].min()) / 2
    z_center = (data[:, 2].max() + data[:, 2].min()) / 2

    # Set axis limits with some padding
    padding = data_range * 0.1
    ax.set_xlim(data[:, 0].min() - padding, data[:, 0].max() + padding)
    ax.set_ylim(data[:, 1].min() - padding, data[:, 1].max() + padding)
    ax.set_zlim(data[:, 2].min() - padding, data[:, 2].max() + padding)

    # Set equal aspect ratio
    ax.set_box_aspect(
        [
            data[:, 0].max() - data[:, 0].min(),
            data[:, 1].max() - data[:, 1].min(),
            data[:, 2].max() - data[:, 2].min(),
        ]
    )

    # Add grid and improve appearance
    ax.grid(True, alpha=0.3)

    # Add some text info
    info_text = f"Points: {len(data):,}"
    if max_range:
        info_text += f" | Range: â‰¤{max_range}m"
    if subsample and subsample > 1:
        info_text += f" | Subsampled: 1/{subsample}"

    ax.text2D(
        0.02,
        0.98,
        info_text,
        transform=ax.transAxes,
        bbox=dict(boxstyle="round,pad=0.3", facecolor="white", alpha=0.8),
        verticalalignment="top",
    )

    return fig, ax


def main():
    parser = argparse.ArgumentParser(description="Visualize point cloud data")
    parser.add_argument(
        "filename",
        nargs="?",
        default="output.txt",
        help="Point cloud file to visualize (default: output.txt)",
    )
    parser.add_argument(
        "--color",
        choices=["height", "distance", "intensity", "uniform"],
        default="height",
        help="Coloring mode (default: height)",
    )
    parser.add_argument(
        "--size", type=float, default=0.5, help="Point size (default: 0.5)"
    )
    parser.add_argument(
        "--max-range", type=float, help="Maximum range to display in meters"
    )
    parser.add_argument(
        "--subsample",
        type=int,
        help="Subsample every Nth point (useful for large datasets)",
    )
    parser.add_argument(
        "--no-stats", action="store_true", help="Skip printing statistics"
    )
    parser.add_argument(
        "--save", type=str, help="Save plot to file instead of showing interactively"
    )

    args = parser.parse_args()

    # Load the point cloud data
    data = load_point_cloud(args.filename)

    # Print statistics unless disabled
    if not args.no_stats:
        analyze_point_cloud(data)

    # Create visualization
    print(f"\nCreating visualization...")
    print(f"  Color mode: {args.color}")
    print(f"  Point size: {args.size}")
    if args.max_range:
        print(f"  Max range: {args.max_range}m")
    if args.subsample:
        print(f"  Subsampling: every {args.subsample}th point")

    fig, ax = create_visualization(
        data,
        color_mode=args.color,
        point_size=args.size,
        max_range=args.max_range,
        subsample=args.subsample,
    )

    if args.save:
        print(f"Saving plot to {args.save}...")
        plt.savefig(args.save, dpi=300, bbox_inches="tight")
        print("Saved!")
    else:
        print("\nShowing interactive plot...")
        print("Mouse controls:")
        print("  - Left click + drag: Rotate view")
        print("  - Right click + drag: Pan view")
        print("  - Scroll wheel: Zoom in/out")
        print("  - Close window or Ctrl+C to exit")

        plt.show()


if __name__ == "__main__":
    main()
